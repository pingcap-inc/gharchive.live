# MySQL SQL
# Table Schema
Table github_events, columns = [id, type, created_at, repo_id, repo_name, actor_id, actor_login, additions, deletions, action, number, org_login, org_id, state, closed_at, comments, pr_merged_at, pr_merged, pr_changed_files, pr_review_comments, pr_or_issue_id, push_size, push_distinct_size, creator_user_login, creator_user_id, pr_or_issue_created_at]
- Column type, enums = ['PullRequestEvent', 'PushEvent', 'IssueCommentEvent', 'IssuesEvent', 'PullRequestReviewCommentEvent', 'WatchEvent', 'CreateEvent', 'DeleteEvent', 'ForkEvent', 'ReleaseEvent']
- Column action:
* type in [PullRequestReviewCommentEvent, IssueCommentEvent, ReviewEvent]: created
* type in [PullRequestEvent, IssuesEvent]: opened, closed, reopened
- Column number, number is issue number
- Column created_at, closed_at, pr_merged_at, pr_or_issue_created_at DEFAULT '1970-01-01 00:00:00'
- Column additions, deletions: only existed in PullRequestEvent
- Column actor_id, actor_login: who trigger the event

Table github_repos, columns = [repo_id, repo_name, owner_id, owner_login, owner_is_org, description, primary_language, license, stars, forks, parent_repo_id, is_archived, is_deleted, latest_released_at, pushed_at, created_at, updated_at]
- Column repo_id: primary key
- Column primary_language: refers to the primary programming language by the repo, not the framework or software, invalid = ['']

Table github_users, columns = [id, login, type, name, organization, country_code, followers, followings, created_at, updated_at]
- Column id: primary key
- Column type, enums = ['USR', 'ORG']
- Column country_code, invalid = ['', 'N/A', 'UND']
- Column organization: include company information, invalid = ['',  null]

Table trending_repos, contains the most popular repositories recently, columns = [repo_name, created_at]
Table github_repo_topics, columns = [repo_id, topic]

# Table Relations
github_events.repo_id = github_repos.repo_id
github_events.actor_id = github_users.id
github_events.actor_login = github_users.login
github_events.creator_user_id = github_users.id
github_repos.owner_id = github_users.id
github_repos.repo_id = github_repo_topics.repo_id
trending_repos.repo_name = github_repos.repo_name

# ChartOptions
type Column = string; // must be the column name in the SQL result!!!
PieChart {label: Column; value: Column;}
LineChart {x: Column; y: Column | Column[];}
BarChart {x: Column; y: Column | Column[];}
MapChart {country_code: Column; value: Column;}
NumberCard {value: Column;}
RepoCard {repo_name: Column;}
PersonalCard {user_login: Column;}
Table {columns: Column[];}

# ChartConfig
type ChartName = 'PieChart' | 'LineChart' | 'BarChart' | 'MapChart' | 'NumberCard' | 'RepoCard' | 'PersonalCard' | 'Table';
interface ChartConfig {chartName: ChartName; title: string; options: ChartOptions;}

use the answer.json template:
{
    "RQ": "The question after revised, marked as RQ, RQ should be a clear and concise statement of the question",
    "keywords": ["Output every key information('who', 'when', 'what', 'time range') in RQ"],
    "links": ["List the GitHub links of the repos mentioned in RQ"],
    "subQuestions": ["List at most 2 important sub-questions started with 'No{n}. ' (`{n}` is a placeholder) in order in array to answer the RQ"],
    "notClear": "What is not clear or needs to narrow down",
    "assumption": "What's your assumptions about RQ and sub-questions",
    "deps": "Dependency graph of each sub-question, Question Number only",
    "CQ": "Integrate (RQ,assumptions) into a clarified question,then diff_words_from(RQ) and mark with (<b>)",
    "sqlCanAnswer": "boolean, whether the RQ about GitHub",
    "sql": "use the best practice to write A SINGLE SQL (You can use Common Table Expressions (CTEs) or subqueries  to ensure that the final SQL statement is an SQL statement, not a combination of multiple SQL statements) to answer the question (RQ)",
    "chart": "must a ChartConfig object"
}

Begin:
Let's think step by step, generate the content for an answer.json file to answer the question "In GitHub, {{question}}" (Do not overthink):
---
answer.json // must only output a pretty JSON!!!
---